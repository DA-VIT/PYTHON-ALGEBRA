# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EKXQYgZpn10J6SR2S-8rYYCgQLbJz44e
"""



"""# üèõÔ∏è UNIVERSIDAD NACIONAL DE SAN ANTONIO ABAD DEL CUSCO

## FACULTAD DE INGENIER√çA INFORM√ÅTICA Y DE SISTEMAS

---

# üìò TRABAJO PRACTICO

## **Aplicaciones de Matrices en la Ingenier√≠a Inform√°tica con Python**

---

**üë®‚Äçüè´ Docente:** Cazorla Medina Edwin  
**üë®‚Äçüéì Integrante:** Araoz Lupinta David  
**üÜî C√≥digo:** 220119  
**üìÖ Semestre:** 2025-I  
**üìç Sede:** Cusco - Per√∫  
**üìÜ A√±o:** 2025  

---

### üìù Descripci√≥n

Este trabajo investigativo presenta una aplicaci√≥n en Python orientada al  
uso de matrices en problemas de ingenier√≠a inform√°tica. Se incluyen operaciones  
como **suma**, **multiplicaci√≥n**, **transposici√≥n**, **determinante** y  
**resoluci√≥n de sistemas de ecuaciones**, haciendo uso de estructuras de datos  
y librer√≠as como **NumPy** para optimizar el an√°lisis computacional.

"""

# ============================================================
# 1. Tipos de Matrices
# ============================================================
# Funci√≥n para verificar si una matriz es una matriz fila
def es_matriz_fila(matriz):
    # Una matriz fila tiene solo una fila
    return len(matriz) == 1

# Funci√≥n para verificar si una matriz es una matriz columna
def es_matriz_columna(matriz):
    # Una matriz columna tiene solo una columna en todas sus filas
    return all(len(fila) == 1 for fila in matriz)

# Funci√≥n para verificar si una matriz es cuadrada
def es_matriz_cuadrada(matriz):
    # Una matriz cuadrada tiene el mismo n√∫mero de filas que de columnas
    return all(len(fila) == len(matriz) for fila in matriz)

# Funci√≥n para verificar si una matriz es diagonal
def es_matriz_diagonal(matriz):
    # Verificamos que sea cuadrada
    if not es_matriz_cuadrada(matriz):
        return False
    # Los elementos fuera de la diagonal principal deben ser cero
    for i in range(len(matriz)):
        for j in range(len(matriz[i])):
            if i != j and matriz[i][j] != 0:
                return False
    return True

# Funci√≥n para verificar si una matriz es la identidad
def es_matriz_identidad(matriz):
    # Verificamos que sea diagonal
    if not es_matriz_diagonal(matriz):
        return False
    # En la diagonal principal los elementos deben ser 1
    for i in range(len(matriz)):
        if matriz[i][i] != 1:
            return False
    return True

# Funci√≥n para verificar si una matriz es nula
def es_matriz_nula(matriz):
    # Todos los elementos deben ser cero
    return all(all(elem == 0 for elem in fila) for fila in matriz)

# Funci√≥n para verificar si una matriz es sim√©trica
def es_matriz_simetrica(matriz):
    # Verificamos que sea cuadrada
    if not es_matriz_cuadrada(matriz):
        return False
    # La matriz debe ser igual a su transpuesta
    for i in range(len(matriz)):
        for j in range(len(matriz)):
            if matriz[i][j] != matriz[j][i]:
                return False
    return True

# ----------------------------
# Ejemplos de uso de funciones
# ----------------------------

A = [[1, 2],
    [3, 4]]

B = [[1, 0, 0],
     [0, 2, 0],
     [0, 0, 3]]

C = [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]

D = [[0, 0],
     [0, 0]]


E = [[1, 2, 3],
     [2, 5, 6],
     [3, 6, 9]]



matriz_fila = [[1, 2, 3]]
matriz_columna = [[1], [2], [3]]


# Imprimimos los resultados
print("¬øEs matriz fila?", es_matriz_fila(matriz_fila))
print("¬øEs matriz columna?", es_matriz_columna(matriz_columna))
print("¬øEs matriz cuadrada?", es_matriz_cuadrada(A))
print("¬øEs matriz diagonal?", es_matriz_diagonal(B))
print("¬øEs matriz identidad?", es_matriz_identidad(C))
print("¬øEs matriz nula?", es_matriz_nula(D))
print("¬øEs matriz sim√©trica?", es_matriz_simetrica(E))

# ============================================================
# 2. Operaciones con Matrices
# ============================================================


# Funci√≥n para sumar dos matrices
def suma_matrices(m1, m2):
    # Verificamos que las dimensiones sean iguales
    # Recorremos cada fila i y cada columna j para sumar los elementos correspondientes
    # Suma: C[i][j] = A[i][j] + B[i][j]
    return [[m1[i][j] + m2[i][j] for j in range(len(m1[0]))] for i in range(len(m1))]

# Funci√≥n para multiplicar una matriz por un escalar
def multiplicacion_escalar(matriz, escalar):
    # Multiplicamos cada elemento de la matriz por el escalar
    # Resultado: C[i][j] = escalar * A[i][j]
    return [[elemento * escalar for elemento in fila] for fila in matriz]

# Funci√≥n para realizar la multiplicaci√≥n matricial (producto de dos matrices)
def multiplicacion_matrices(m1, m2):
    # Verificamos que el n√∫mero de columnas de m1 sea igual al n√∫mero de filas de m2
    # Creamos una matriz resultado vac√≠a
    resultado = []
    for i in range(len(m1)):  # Iteramos sobre las filas de la primera matriz
        fila_resultado = []
        for j in range(len(m2[0])):  # Iteramos sobre las columnas de la segunda matriz
            suma = 0
            for k in range(len(m2)):  # Producto escalar entre fila de m1 y columna de m2
                suma += m1[i][k] * m2[k][j]
            fila_resultado.append(suma)
        resultado.append(fila_resultado)
    return resultado

# Funci√≥n para transponer una matriz
def transponer_matriz(matriz):
    # Intercambiamos las filas por las columnas
    # Si A es de m x n, su transpuesta ser√° de n x m
    # A[i][j] se convierte en A_T[j][i]
    return [[matriz[j][i] for j in range(len(matriz))] for i in range(len(matriz[0]))]

# -----------------------------
# Ejemplos de uso de operaciones
# -----------------------------

# Matrices de ejemplo
A = [[1, 2], [3, 4]]             # Matriz 2x2
B = [[5, 6], [7, 8]]             # Matriz 2x2
escalar = 3                      # Escalar para multiplicaci√≥n
C = [[1, 2, 3], [4, 5, 6]]       # Matriz 2x3
D = [[7, 8], [9, 10], [11, 12]]  # Matriz 3x2

# Resultados de las operaciones
print("Suma de A + B:")
# Suma elemento a elemento: [[1+5, 2+6], [3+7, 4+8]] => [[6, 8], [10, 12]]
print(suma_matrices(A, B))

print("\nMultiplicaci√≥n de A por escalar 3:")
# Cada elemento de A se multiplica por 3: [[3, 6], [9, 12]]
print(multiplicacion_escalar(A, escalar))

print("\nMultiplicaci√≥n matricial C x D:")
# C es 2x3 y D es 3x2 ‚Üí se puede multiplicar
# Resultado ser√° una matriz 2x2
print(multiplicacion_matrices(C, D))

print("\nTransposici√≥n de C:")
# C es 2x3 ‚Üí su transpuesta ser√° 3x2
# Transponemos filas por columnas
print(transponer_matriz(C))

# ============================================================
# 3. M√©todos de Escalonamiento y C√°lculo de Determinantes
# ============================================================
import copy



# Funci√≥n: Eliminaci√≥n de Gauss (escalonamiento superior)
def gauss(matriz):
    A = copy.deepcopy(matriz)  # Copiamos la matriz original para no modificarla
    n = len(A)
    for i in range(n):
        # Buscamos el pivote y hacemos intercambio de filas si es necesario
        if A[i][i] == 0:
            for j in range(i+1, n):
                if A[j][i] != 0:
                    A[i], A[j] = A[j], A[i]
                    break
        # Eliminamos los elementos debajo del pivote
        for j in range(i+1, n):
            if A[i][i] == 0:
                continue
            factor = A[j][i] / A[i][i]
            for k in range(i, len(A[0])):
                A[j][k] -= factor * A[i][k]
    return A

# Funci√≥n: Eliminaci√≥n de Gauss-Jordan (matriz identidad)
def gauss_jordan(matriz):
    A = copy.deepcopy(matriz)
    n = len(A)
    for i in range(n):
        # Normalizamos el pivote a 1
        if A[i][i] != 0:
            factor = A[i][i]
            A[i] = [x / factor for x in A[i]]
        # Hacemos ceros arriba y abajo del pivote
        for j in range(n):
            if i != j and A[j][i] != 0:
                factor = A[j][i]
                A[j] = [A[j][k] - factor * A[i][k] for k in range(len(A[0]))]
    return A

# -------------------------------
# M√âTODOS DE DETERMINANTE
# -------------------------------

# Determinante por escalonamiento (Gauss)
def determinante_por_escalonamiento(matriz):
    A = copy.deepcopy(matriz)
    n = len(A)
    det = 1
    for i in range(n):
        if A[i][i] == 0:
            for j in range(i+1, n):
                if A[j][i] != 0:
                    A[i], A[j] = A[j], A[i]
                    det *= -1  # Intercambiar filas cambia el signo del determinante
                    break
        if A[i][i] == 0:
            return 0  # Columna sin pivote ‚Üí determinante cero
        det *= A[i][i]
        for j in range(i+1, n):
            factor = A[j][i] / A[i][i]
            for k in range(i, n):
                A[j][k] -= factor * A[i][k]
    return round(det, 5)

# Regla de Sarrus (solo para matrices 3x3)
def determinante_sarrus(matriz):
    # Aplicamos la regla de Sarrus directamente
    a, b, c = matriz[0]
    d, e, f = matriz[1]
    g, h, i = matriz[2]
    return a*e*i + b*f*g + c*d*h - c*e*g - b*d*i - a*f*h

# Expansi√≥n por cofactores (recursiva)
def determinante_cofactores(matriz):
    n = len(matriz)
    if n == 1:
        return matriz[0][0]
    if n == 2:
        return matriz[0][0]*matriz[1][1] - matriz[0][1]*matriz[1][0]

    det = 0
    for j in range(n):
        # Obtenemos el menor (submatriz) eliminando la primera fila y la columna j
        menor = [fila[:j] + fila[j+1:] for fila in matriz[1:]]
        cofactor = ((-1)**j) * matriz[0][j] * determinante_cofactores(menor)
        det += cofactor
    return det

# -------------------------------
# EJEMPLOS
# -------------------------------

M = [
    [2, 1, -1],
    [-3, -1, 2],
    [-2, 1, 2]
]

print("Matriz original:")
for fila in M: print(fila)

print("\nGauss (escalonamiento superior):")
gauss_res = gauss(M)
for fila in gauss_res: print(fila)

print("\nGauss-Jordan (reducci√≥n completa):")
gj_res = gauss_jordan(M)
for fila in gj_res: print(fila)

print("\nDeterminante por escalonamiento:", determinante_por_escalonamiento(M))
print("Determinante por regla de Sarrus (3x3):", determinante_sarrus(M))
print("Determinante por cofactores:", determinante_cofactores(M))

# ============================================================
# 4. FUNCIONES ADICIONALES DE MATRICES
# ============================================================

# Funci√≥n para obtener la submatriz eliminando la fila i y columna j
def submatriz(matriz, i, j):
    return [fila[:j] + fila[j+1:] for k, fila in enumerate(matriz) if k != i]

# Funci√≥n recursiva para calcular el determinante usando cofactores
def determinante_cofactores(matriz):
    n = len(matriz)
    if n == 1:
        return matriz[0][0]
    if n == 2:
        return matriz[0][0]*matriz[1][1] - matriz[0][1]*matriz[1][0]
    det = 0
    for j in range(n):
        signo = (-1) ** j
        sub = submatriz(matriz, 0, j)
        det += signo * matriz[0][j] * determinante_cofactores(sub)
    return det

# Funci√≥n para calcular la matriz de cofactores
def cofactores(matriz):
    n = len(matriz)
    cof = []
    for i in range(n):
        fila_cof = []
        for j in range(n):
            menor = submatriz(matriz, i, j)
            signo = (-1) ** (i + j)
            det_menor = determinante_cofactores(menor)
            fila_cof.append(signo * det_menor)
        cof.append(fila_cof)
    return cof

# Funci√≥n para transponer una matriz
def transponer_matriz(matriz):
    return [[matriz[j][i] for j in range(len(matriz))] for i in range(len(matriz[0]))]

# Funci√≥n para calcular la matriz adjunta
def matriz_adjunta(matriz):
    # La adjunta es la transpuesta de la matriz de cofactores
    return transponer_matriz(cofactores(matriz))

# Funci√≥n para aplicar el m√©todo de Gauss (escalonamiento)
def gauss(matriz):
    from copy import deepcopy
    A = deepcopy(matriz)
    n = len(A)
    m = len(A[0])
    fila = 0
    for col in range(m):
        if fila >= n:
            break
        # Buscar el m√°ximo en la columna
        max_fila = max(range(fila, n), key=lambda i: abs(A[i][col]))
        if A[max_fila][col] == 0:
            continue
        A[fila], A[max_fila] = A[max_fila], A[fila]
        # Hacer ceros debajo del pivote
        for i in range(fila + 1, n):
            factor = A[i][col] / A[fila][col]
            A[i] = [a - factor * b for a, b in zip(A[i], A[fila])]
        fila += 1
    return A

# Funci√≥n para calcular el rango de una matriz usando escalonamiento
def rango_matriz(matriz):
    A = gauss(matriz)
    rango = 0
    for fila in A:
        if any(valor != 0 for valor in fila):
            rango += 1
    return rango

# ============================================================
# EJEMPLOS DE USO
# ============================================================

print("==== SUBMATRIZ ====")
matriz = [
    [1, 2, 3],
    [0, 4, 5],
    [7, 8, 9]
]
#eliminamos la fila 0 y columna 1
print("Matriz original",matriz)
print(submatriz(matriz, 0, 1))  # [[0, 5], [7, 9]]

print("\n==== COFACTORES ====")
print(cofactores(matriz))  # Matriz de cofactores

print("\n==== MATRIZ ADJUNTA ====")
print(matriz_adjunta(matriz))  # Adjunta (transpuesta de cofactores)

print("\n==== RANGO MATRIZ ====")
matriz_rango = [
    [1, 2, 3],
    [2, 4, 6],
    [1, 1, 1]
]
print(matriz_rango)
print("Rango:", rango_matriz(matriz_rango))  # Rango: 2

# ============================================================
# 5. M√©todos para la Resoluci√≥n de Sistemas Lineales
# ============================================================

# M√©todo de eliminaci√≥n de Gauss
def resolver_gauss(matriz, vector):
    n = len(matriz)
    A = [fila + [vector[i]] for i, fila in enumerate(copy.deepcopy(matriz))]

    # Escalonamiento
    for i in range(n):
        if A[i][i] == 0:
            for j in range(i+1, n):
                if A[j][i] != 0:
                    A[i], A[j] = A[j], A[i]
                    break
        for j in range(i+1, n):
            factor = A[j][i] / A[i][i]
            for k in range(i, n + 1):
                A[j][k] -= factor * A[i][k]

    # Sustituci√≥n regresiva
    x = [0] * n
    for i in reversed(range(n)):
        suma = sum(A[i][j] * x[j] for j in range(i+1, n))
        x[i] = (A[i][n] - suma) / A[i][i]
    return x

# M√©todo de Gauss-Jordan (resoluci√≥n directa)
def resolver_gauss_jordan(matriz, vector):
    n = len(matriz)
    A = [fila + [vector[i]] for i, fila in enumerate(copy.deepcopy(matriz))]

    # Reducci√≥n completa
    for i in range(n):
        factor = A[i][i]
        A[i] = [x / factor for x in A[i]]
        for j in range(n):
            if i != j:
                factor = A[j][i]
                A[j] = [A[j][k] - factor * A[i][k] for k in range(n+1)]

    # Soluci√≥n directamente en la √∫ltima columna
    return [fila[-1] for fila in A]

# M√©todo de la matriz inversa para resolver Ax = b
def resolver_inversa(matriz, vector):
    det = determinante_cofactores(matriz)
    if det == 0:
        raise ValueError("La matriz no es invertible")
    adj = matriz_adjunta(matriz)
    inversa = multiplicacion_escalar(adj, 1/det)
    resultado = multiplicacion_matrices(inversa, [[v] for v in vector])
    return [fila[0] for fila in resultado]

# M√©todo de la Regla de Cramer
def resolver_cramer(matriz, vector):
    detA = determinante_cofactores(matriz)
    if detA == 0:
        raise ValueError("El sistema no tiene soluci√≥n √∫nica (det=0)")
    n = len(matriz)
    soluciones = []
    for i in range(n):
        Ai = copy.deepcopy(matriz)
        for j in range(n):
            Ai[j][i] = vector[j]
        soluciones.append(determinante_cofactores(Ai) / detA)
    return soluciones
# -----------------------------------------
# EJEMPLOS
# -----------------------------------------

A = [[2, -1, 0], [1, 2, -1], [3, 1, 1]]
b = [1, 2, 3]

print("Matriz adjunta:")
for fila in matriz_adjunta(A): print(fila)

print("\nRango de la matriz A:", rango_matriz(A))

print("\nSoluci√≥n por Gauss:")
print(resolver_gauss(A, b))

print("\nSoluci√≥n por Gauss-Jordan:")
print(resolver_gauss_jordan(A, b))

print("\nSoluci√≥n por matriz inversa:")
print(resolver_inversa(A, b))

print("\nSoluci√≥n por regla de Cramer:")
print(resolver_cramer(A, b))

